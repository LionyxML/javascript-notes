#+TITLE: JavaScript Notes
#+AUTHOR: Rahul M. Juliato
#+OPTIONS: toc:nil

* What is: Closure
Clojures are important because they control what is and isn't in scope
in a particular funcion, along with which variables are shared between
sibling functions in the same containing scope. Understanding how
variables and functions relate to each other is criticalto
understanding what's going on in your code, in both functional and
object oriented programming styles.

#+BEGIN_SRC
Coding without understanding of Closures is like trying to
speak English without understanding the grammar rules.
You might be able to get your ideas across, but probably a
bit awkaardly.
#+END_SRC

In JS closures are frequently used for data privacy, in event handlers
and callback functions, and in partial applications, currying and
other functional programming patterns.

** What is it?
Is the combination of a function bundled togheter (enclosed) with
references to its surrounding sate (the **lexical environment**). In
other words, a closure gives you access to an outer function's scope
from a inner function. In JavaScript, closures are created every time
a function is created, at function creation time.

To use a Closure, defina function inside another function and expose
it. To expose a function, return it or pass it to another function.

The inner function will have access to the variables in the outer
function scope, even after the outer function has returned.

** Using Closures (Examples)
Among other things, closures are commonly used to give objects data
privacy. Data privary is an essential property that helps us **program
to an interface, not an implementation**. This is an important concept
that helps us build more robust software because implementation
details are more likely to change in breaking ways than interface
contracts.

In JavaScript, closures are the primary mechanism used to enable data
privacy. When you use closures for data privacy, the enclosed
variables are only in scope within the containing (outer)
function. You canâ€™t get at the data from an outside scope except
through the objectâ€™s privileged methods. In JavaScript, any exposed
method defined within the closure scope is privileged. For example:

#+BEGIN_SRC
const getSecret = (secret) => {
  return {
    get: () => secret
  };
};

test('Closure for object privacy.', assert => {
  const msg = '.get() should have access to the closure.';
  const expected = 1;
  const obj = getSecret(1);

  const actual = obj.get();

  try {
    assert.ok(secret, 'This throws an error.');
  } catch (e) {
    assert.ok(true, `The secret var is only available
      to privileged methods.`);
  }

  assert.equal(actual, expected, msg);
  assert.end();
});
#+END_SRC

In the example above, the `.get()` method is defined inside the scope
of `getSecret()`, which gives it access to any variables from
`getSecret()`, and makes it a privileged method. In this case, the
parameter, `secret`.

Objects are not the only way to produce data privacy. Closures can
also be used to create stateful functions whose return values may be
influenced by their internal state, e.g.:

const secret = msg => () => msg;

#+BEGIN_SRC
// Secret - creates closures with secret messages.
// https://gist.github.com/ericelliott/f6a87bc41de31562d0f9
// https://jsbin.com/hitusu/edit?html,js,output

// secret(msg: String) => getSecret() => msg: String
const secret = (msg) => () => msg;

test('secret', assert => {
  const msg = 'secret() should return a function that returns the passed secret.';

  const theSecret = 'Closures are easy.';
  const mySecret = secret(theSecret);

  const actual = mySecret();
  const expected = theSecret;

  assert.equal(actual, expected, msg);
  assert.end();
});
#+END_SRC

In functional programming, closures are frequently used for partial
application & currying. This requires some definitions:

*** Application:
The process of applying a function to its arguments in order to
produce a return value.

*** Partial Application:
The process of applying a function to some of its arguments. The
partially applied function gets returned for later use. Partial
application fixes (partially applies the function to) one or more
arguments inside the returned function, and the returned function
takes the remaining parameters as arguments in order to complete the
function application.

Partial application takes advantage of closure scope in order to fix
parameters. You can write a generic function that will partially apply
arguments to the target function. It will have the following
signature:

#+BEGIN_SRC
  partialApply(targetFunction: Function, ...fixedArgs: Any[]) =>
  functionWithFewerParams(...remainingArgs: Any[])
#+END_SRC

It will take a function that takes any number of arguments, followed
by arguments we want to partially apply to the function, and returns a
function that will take the remaining arguments

An example will help. Say you have a function that adds two numbers:
#+BEGIN_SRC
const add = (a, b) => a + b;
#+END_SRC

Now you want a function that adds 10 to any number. We'll call it
`add10()`. The result of `add10(5)` should be `15`. Our
`partialApply()` function can make that happen:

#+BEGIN_SRC
const add10 = partialApply(add, 10);
add10(5);
#+END_SRC

In this example, the argument, `10` becomes a fixed parameter
remembered inside the `add10()` closure scope.

Let's look at a possible `partialApply()` implementation:

#+BEGIN_SRC
// Generic Partial Application Function
// https://jsbin.com/biyupu/edit?html,js,output
// https://gist.github.com/ericelliott/f0a8fd662111ea2f569e

// partialApply(targetFunction: Function, ...fixedArgs: Any[]) =>
//   functionWithFewerParams(...remainingArgs: Any[])
const partialApply = (fn, ...fixedArgs) => {
  return function (...remainingArgs) {
    return fn.apply(this, fixedArgs.concat(remainingArgs));
  };
};


test('add10', assert => {
  const msg = 'partialApply() should partially apply functions'

  const add = (a, b) => a + b;

  const add10 = partialApply(add, 10);


  const actual = add10(5);
  const expected = 15;

  assert.equal(actual, expected, msg);
});
#+END_SRC

As you can see, it simply returns a function which retains access to
the `fixedArgs` arguments that were passed into the `partialApply()`
function.


** Source:
Heavly based on:
[[https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36]]

* What is: Pure Functions
** General Definition
Is a function where:
- Given the same input, always returns the same output
- Produces no side effects
** Functions as a whole
Is a process of taking some input, called arguments, and producing some output calle return value.

Main purposes:
- Mapping: Proce output based on given inputs. Maps input values to output values
- Procedures: A function to perform a sequence of steps. This is style is procedural programming.
- I/O: In order to communicate with the system: screen, storage, logs, network.

** Back to definition
If a function where:
- Given the same input, always returns the same output
- Produces no side effects

If I have a function like:
#+BEGIN_SRC
function double(number) {
    return 2 * number;
}
#+END_SRC

I can say that these are both "the same"
#+BEGIN_SRC
console.log(double(5));
console.log(10);        // They produces the same result
#+END_SRC

If you want **Referential Transparency** you need to use pure functions.

A dead giveaway that a function is impure is if it makes sense to call
it without using its return value. For pure functions, that's a nope.

** Recomendation
Favor pure functions: If it is pratical to implement a program
requirement using pure functions, you should use them over other
options. They are the simples reusable build blocks of code in a program.

** The most important design principle (KISS)
Keep it Simple Stupid or,
Keep it Stupid Simple

Pure functions are completely independent of outside state, and as
such, they are immune to entire classes of bugs that happen with a
shared mutable state.

This independent nature makes them great candidates for parallel
processing across many CPUs and distribute clusters.

They are also easier to move around, refactor, and reorganize in the
code, making programs more flexible and adaptable to future changes.

** Problem with Shared State

In an example: if you make requests from a query textfield as the user types.
You may have times where th last request "Java" for example comes and ocupies
the UI response element, before the request for "JavaScript" was even sent.

To fix this, you should build a manager that cancels the previous AJAX request.

Martin Odersky (Creator of Scala) puts it:
`non-determinism = parallel processing + mutable state`

You should avoid it.

Program determinism is a LOT desirable in computing. If you think JS
is imune because it only use single thread. Remember thata AJAX, API
I/O event listeners, web workers, iframes and timeouts can introduce
indeterminism into your program. Combine that with shared state, you
have a recipe for bugs.

** Given the same Input, Always Retun the Same Output
Our `double` function will always return 10 for 5 as paramater, it
does'nt matter how many times we call it

But we can't say the same for `Math.random()` for example.

#+BEGIN_SRC
Math.random();
// 0.8335683328172347

Math.random();
// 0.8910118593581697

Math.random();
//0.3099123827043109
#+END_SRC

Even tough we didn't pass any arguments into any of the function
calls, they produced different output. This function is not pure.

#+BEGIN_SRC
const time = () => new Date().toLocaleTimeString();

time(); // '8:45:51 AM'
#+END_SRC

This is also not pure, even tought it repeats its output one time each day.

Now an example of pure function:
#+BEGIN_SRC
const highpass = (cutoff, value) => value >= cutoff;

highpass(5, 5); // => true  Always the same result given the same inputs
highpass(5, 5); // => true
highpass(5, 5); // => true

highpass(5, 123); // true  Many inputs may map to the same ouputs
highpass(5, 6);   // true
highpass(5, 18);  // true
highpass(5, 1);   // false
highpass(5, 3);   // false
highpass(5, 4);   // false
#+END_SRC

A pure function must not rely on any external mutable state, because
it would no longer be determinisstic or referentially transparent.

** Pure functions Produce No SIDE EFFECTS
A pure function produces no side effects, which means that it can't
alter any external state.

*** Immutability
JavaScript's object arguments are references, which means that if a
function were to mutate a property on an object or array parameter,
that would mutate state that is accessible outside the function. Pure
functions must not mutate external state.

Consider this mutating, impure `addToCart()` function:

#+BEGIN_SRC
// impure addToCart mutates existing cart
const addToCart = (cart, item, quantity) => {
  cart.items.push({
    item,
    quantity
  });
  return cart;
};


test('addToCart()', assert => {
  const msg = 'addToCart() should add a new item to the cart.';
  const originalCart =     {
    items: []
  };
  const cart = addToCart(
    originalCart,
    {
      name: "Digital SLR Camera",
      price: '1495'
    },
    1
  );

  const expected = 1; // num items in cart
  const actual = cart.items.length;

  assert.equal(actual, expected, msg);

  assert.deepEqual(originalCart, cart, 'mutates original cart.');
  assert.end();
});
#+END_SRC

It works by passing a cart and item to add to the cart. The function
then returns the same cart, with the item added to it.

The problem is that we've just mutated some shared state. Other
functions may be relying on that cart object state to be what it was
before the function was called and now we have to worry about what
impact it will have on the program logic if we change the
order. Refactoring the code could result in bugs popping up and
unhappy customers.

Consider this version:
#+BEGIN_SRC
// Pure addToCart() returns a new cart
// It does not mutate the original.
const addToCart = (cart, item, quantity) => {
  const newCart = lodash.cloneDeep(cart);

  newCart.items.push({
    item,
    quantity
  });
  return newCart;

};


test('addToCart()', assert => {
  const msg = 'addToCart() should add a new item to the cart.';
  const originalCart = {
    items: []
  };

  // deep-freeze on npm
  // throws an error if original is mutated
  deepFreeze(originalCart);

  const cart = addToCart(
    originalCart,
    {
      name: "Digital SLR Camera",
      price: '1495'
    },
    1
  );


  const expected = 1; // num items in cart
  const actual = cart.items.length;

  assert.equal(actual, expected, msg);

  assert.notDeepEqual(originalCart, cart,
    'should not mutate original cart.');
  assert.end();
});
#+END_SRC

In this example, we have an array nested in an object, which is why I
reached for a deep clone. This is more complex state than youâ€™ll
typically be dealing with. For most things, you can break it down into
smaller chunks.

For example, Redux lets you compose reducers rather
than deal with the entire app state inside each reducer. The result is
that you don't have to create a deep clone of the entire app state
every time you want to update just a small part of it. Instead, you
can use non-destructive array methods, or `Object.assign()` to update
a small part of the app state.

** Source
This topic is based on:
[[https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976]]

* New features of ES13
** Class Field Declarations

Before ES13 we could not declare class fields outside the constructor:
#+BEGIN_SRC
class Car {
  constructor() {
    this.color = 'blue';
    this.age = 2;
  }
}
const car = new Car();
console.log(car.color); // blue
console.log(car.age); // 2
#+END_SRC

ES13 removes this limitation:
#+BEGIN_SRC
class Car {
  color = 'blue';
  age = 2;
}
const car = new Car();
console.log(car.color); // blue
console.log(car.age); // 2
#+END_SRC

** Private Methods and Fields
Members were usually prefixed with an _ to indicate it should be private.
But could still be accessed from outside.
#+BEGIN_SRC
class Person {
  _firstName = 'Joseph';
  _lastName = 'Stevens';
  get name() {
    return `${this._firstName} ${this._lastName}`;
  }
}

const person = new Person();
console.log(person.name); // Joseph Stevens

// Members intended to be private can still be accessed
// from outside the class
console.log(person._firstName); // Joseph
console.log(person._lastName); // Stevens

// They can also be modified
person._firstName = 'Robert';
person._lastName = 'Becker';
console.log(person.name); // Robert Becker
#+END_SRC

Now we use # to add private fields to our classes
#+BEGIN_SRC
class Person {
  #firstName = 'Joseph';
  #lastName = 'Stevens';
  get name() {
    return `${this.#firstName} ${this.#lastName}`;
  }
}

const person = new Person();

console.log(person.name);

// SyntaxError: Private field '#firstName' must be
// declared in an enclosing class
console.log(person.#firstName);
console.log(person.#lastName);
#+END_SRC

** await Operator at Top level
Previously we could only use await with async function.
We could not use this in the global scope.
#+BEGIN_SRC
  function setTimeoutAsync(timeout) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, timeout);
  });
}
  
// SyntaxError: await is only valid in async functions
await setTimeoutAsync(3000);
#+END_SRC

Agora Ã© possÃ­vel:
#+BEGIN_SRC
function setTimeoutAsync(timeout) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, timeout);
  });
}
  
// Waits for timeout - no error thrown
await setTimeoutAsync(3000);
#+END_SRC

** Static Class Fields and Static Private Methods
We can now declare static fields and static private methods for a
class in ES13. Static methods can access other private/public static
members in the class using the this keyword, and instance methods can
access them using this.constructor.

#+BEGIN_SRC
class Person {
  static #count = 0;
  static getCount() {
    return this.#count;
  }
  constructor() {
    this.constructor.#incrementCount();
  }
  static #incrementCount() {
    this.#count++;
  }
}

const person1 = new Person();
const person2 = new Person();
console.log(Person.getCount()); // 2
#+END_SRC

** Class static Block
ES13 allows the definition of static blocks that will be executed only
once, at the creation of the class. This is similar to static
constructors in other languages with support for object-oriented
programming, like C# and Java.

A class can have any number of static {} initialization blocks in its
class body. They will be executed, along with any interleaved static
field initializers, in the order they are declared. We can use the
super property in a static block to access properties of the super
class.

#+BEGIN_SRC
class Vehicle {
  static defaultColor = 'blue';
}

class Car extends Vehicle {
  static colors = [];
  static {
    this.colors.push(super.defaultColor, 'red');
  }
  static {
    this.colors.push('green');
  }
}

console.log(Car.colors); // [ 'blue', 'red', 'green' ]
#+END_SRC

** Ergonomic Brand Checks for Private Fields
We can use this new feature to check if an object has a particular private field in it, using the in operator.
#+BEGIN_SRC
class Car {
  #color;
  hasColor() {
    return #color in this;
  }
}

const car = new Car();
console.log(car.hasColor()); // true;
#+END_SRC

The in operator can correctly distinguish private fields with the same names from different classes:
#+BEGIN_SRC
class Car {
  #color;
  hasColor() {
    return #color in this;
  }
}
  
class House {
  #color;
  hasColor() {
    return #color in this;
  }
}
  
const car = new Car();
const house = new House();
console.log(car.hasColor()); // true;
console.log(car.hasColor.call(house)); // false
console.log(house.hasColor()); // true
console.log(house.hasColor.call(car)); // false
#+END_SRC

** at() Method for Indexing
We typically use square brackets ([]) in JavaScript to access the Nth
element of an array, which is usually a simple process. We just access
the N - 1 property of the array.

#+BEGIN_SRC
const arr = ['a', 'b', 'c', 'd'];
console.log(arr[1]); // b
#+END_SRC

However, we have to use an index of arr.length - N if we want to
access the Nth item from the end of the array with square brackets.

#+BEGIN_SRC
const arr = ['a', 'b', 'c', 'd'];

// 1st element from the end
console.log(arr[arr.length - 1]); // d

// 2nd element from the end
console.log(arr[arr.length - 2]); // c
#+END_SRC

The new at() method lets us do this more concisely and
expressively. To access the Nth element from the end of the array, we
simply pass a negative value of -N to at().

#+BEGIN_SRC
const arr = ['a', 'b', 'c', 'd'];

// 1st element from the end
console.log(arr.at(-1)); // d

// 2nd element from the end
console.log(arr.at(-2)); // c
#+END_SRC

Apart from arrays, strings and TypedArray objects also now have at() methods.

#+BEGIN_SRC
const str = 'Coding Beauty';

console.log(str.at(-1)); // y
console.log(str.at(-2)); // t

const typedArray = new Uint8Array([16, 32, 48, 64]);

console.log(typedArray.at(-1)); // 64
console.log(typedArray.at(-2)); // 48  
#+END_SRC

** RegExp Match Indices
This new feature allows us to specify that we want the get both the
starting and ending indices of the matches of a RegExp object in a
given string.  Previously, we could only get the starting index of a
regex match in a string.

#+BEGIN_SRC
const str = 'sun and moon';
const regex = /and/;
const matchObj = regex.exec(str);

// [ 'and', index: 4, input: 'sun and moon', groups: undefined ]
console.log(matchObj);
#+END_SRC

We can now specify a d regex flag to get the two indices where the
match starts and ends.  With the d flag set, the object returned will
have an indices property that contains the starting and ending
indices.

#+BEGIN_SRC
const str = 'sun and moon';
const regex = /and/d;
const matchObj = regex.exec(str);
/*
[
  'and',
  index: 4,
  input: 'sun and moon',
  groups: undefined,
  indices: [ [ 4, 7 ], groups: undefined ]
]
 */
console.log(matchObj);
#+END_SRC

** Object.hasOwn() Method
In JavaScript, we can use the Object.prototype.hasOwnProperty() method
to check if an object has a given property.

#+BEGIN_SRC
class Car {
  color = 'green';
  age = 2;
}
const car = new Car();

console.log(car.hasOwnProperty('age')); // true
console.log(car.hasOwnProperty('name')); // false
#+END_SRC

But there are certain problems with this approach. For one, the
Object.prototype.hasOwnProperty() method is not protected - it can be
overridden by defining a custom hasOwnProperty() method for a class,
which could have completely different behavior from

Object.prototype.hasOwnProperty().

#+BEGIN_SRC
class Car {
  color = 'green';
  age = 2;
  // This method does not tell us whether an object of
  // this class has a given property.
  hasOwnProperty() {
    return false;
  }
}

const car = new Car();

console.log(car.hasOwnProperty('age')); // false
console.log(car.hasOwnProperty('name')); // false
#+END_SRC

Another issue is that for objects created with a null prototype (using
Object.create(null)), trying to call this method on them will cause an
error.

#+BEGIN_SRC
const obj = Object.create(null);
obj.color = 'green';
obj.age = 2;

// TypeError: obj.hasOwnProperty is not a function
console.log(obj.hasOwnProperty('color'));
#+END_SRC

One way to solve these issues is to use to call the call() method on
the Object.prototype.hasOwnProperty Function property, like this:

#+BEGIN_SRC
const obj = Object.create(null);
obj.color = 'green';
obj.age = 2;
obj.hasOwnProperty = () => false;

console.log(Object.prototype.hasOwnProperty.call(obj, 'color')); // true
console.log(Object.prototype.hasOwnProperty.call(obj, 'name')); // false  
#+END_SRC

This isnâ€™t very convenient. We can write a reusable function to avoid
repeating ourselves:

#+BEGIN_SRC
function objHasOwnProp(obj, propertyKey) {
  return Object.prototype.hasOwnProperty.call(obj, propertyKey);
}

const obj = Object.create(null);
obj.color = 'green';
obj.age = 2;
obj.hasOwnProperty = () => false;

console.log(objHasOwnProp(obj, 'color')); // true
console.log(objHasOwnProp(obj, 'name')); // false
#+END_SRC

No need for that though, as we can use the new built-in
Object.hasOwn() method. Like our reusable function, it takes an object
and property as arguments and returns true if the specified property
is a direct property of the object. Otherwise, it returns false.

#+BEGIN_SRC
const obj = Object.create(null);
obj.color = 'green';
obj.age = 2;
obj.hasOwnProperty = () => false;

console.log(Object.hasOwn(obj, 'color')); // true
console.log(Object.hasOwn(obj, 'name')); // false  
#+END_SRC

** Error Cause
Error objects now have a cause property for specifying the original
error that caused the error about to be thrown. This helps to add
additional contextual information to the error and assist the
diagnosis of unexpected behavior. We can specify the cause of an error
by setting a cause property on an object passed as the second argument
to the Error() constructor.

#+BEGIN_SRC
function userAction() {
  try {
    apiCallThatCanThrow();
  } catch (err) {
    throw new Error('New error message', { cause: err });
  }
}
try {
  userAction();
} catch (err) {
  console.log(err);
  console.log(`Cause by: ${err.cause}`);
}
#+END_SRC

** Array Find from Last
In JavaScript, we can already use the Array find() method to find an
element in an array that passes a specified test condition. Similarly,
we can use findIndex() to find the index of such an element. While
find() and findIndex() both start searching from the first element of
the array, there are instances where it would be preferable to start
the search from the last element instead.

There are scenarios where we know that finding from the last element
might achieve better performance. For example, here weâ€™re trying to
get the item in the array with the value prop equal to y. With find()
and findIndex():

#+BEGIN_SRC
const letters = [
  { value: 'v' },
  { value: 'w' },
  { value: 'x' },
  { value: 'y' },
  { value: 'z' },
];

const found = letters.find((item) => item.value === 'y');
const foundIndex = letters.findIndex((item) => item.value === 'y');

console.log(found); // { value: 'y' }
console.log(foundIndex); // 3  
#+END_SRC

This works, but as the target object is closer to the tail of the
array, we might be able to make this program run faster if we use the
findLast() and findLastIndex() methods to search the array from the
end.

#+BEGIN_SRC
const letters = [
  { value: 'v' },
  { value: 'w' },
  { value: 'x' },
  { value: 'y' },
  { value: 'z' },
];

const found = letters.findLast((item) => item.value === 'y');
const foundIndex = letters.findLastIndex((item) => item.value === 'y');

console.log(found); // { value: 'y' }
console.log(foundIndex); // 3  
#+END_SRC

Another use case might require that we specifically search the array
from the end to get the correct item. For example, if we want to find
the last even number in a list of numbers, find() and findIndex()
would produce a wrong result:

#+BEGIN_SRC
const nums = [7, 14, 3, 8, 10, 9];
// gives 14, instead of 10

const lastEven = nums.find((value) => value % 2 === 0);
// gives 1, instead of 4

const lastEvenIndex = nums.findIndex((value) => value % 2 === 0);
console.log(lastEven); // 14
console.log(lastEvenIndex); // 1  
#+END_SRC

We could call the reverse() method on the array to reverse the order
of the elements before calling find() and findIndex(). But this
approach would cause unnecessary mutation of the array, as reverse()
reverses the elements of an array in place. The only way to avoid this
mutation would be to make a new copy of the entire array, which could
cause performance problems for large arrays.

Also, findIndex() would still not work on the reversed array, as
reversing the elements would also mean changing the indexes they had
in the original array. To get the original index, we would need to
perform an additional calculation, which means writing more code.

#+BEGIN_SRC
const nums = [7, 14, 3, 8, 10, 9];

// Copying the entire array with the spread syntax before
// calling reverse()
const reversed = [...nums].reverse();

// correctly gives 10

const lastEven = reversed.find((value) => value % 2 === 0);
// gives 1, instead of 4

const reversedIndex = reversed.findIndex((value) => value % 2 === 0);
// Need to re-calculate to get original index

const lastEvenIndex = reversed.length - 1 - reversedIndex;

console.log(lastEven); // 10
console.log(reversedIndex); // 1
console.log(lastEvenIndex); // 4  
#+END_SRC

Itâ€™s in cases like where the findLast() and findLastIndex() methods
come in handy.

#+BEGIN_SRC
const nums = [7, 14, 3, 8, 10, 9];

const lastEven = nums.findLast((num) => num % 2 === 0);

const lastEvenIndex = nums.findLastIndex((num) => num % 2 === 0);

console.log(lastEven); // 10
console.log(lastEvenIndex); // 4  
#+END_SRC

** Source
This topic came from:
[[https://medium.com/javascript-in-plain-english/es13-javascript-features-eed7ed2f1497]]

